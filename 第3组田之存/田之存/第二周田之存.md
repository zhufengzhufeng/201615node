####bootstrap栅格化布局，一共12列
```
<div class="container">
   <div class="row">
     <div class="col-md-12"></div>
   </div>
</div>
```
ng-bind-html
$sce.trustAsHtml()

####angualr的指令
#####指令分为两类
- 自带指令
- 自定义指令
   - 装饰指令：赋予标签一些功能  link函数
   - 组件式指令：把标签替换成一个组件  template模板
#####angular的指令的四种格式
- 1、元素Element E
```
<hello></hello>
```
- 2、属性Attribute A
```
<div hello></div>
```
- 3、类名Class C
```
<div class="hello"></div>
```
- 4、注释Comment M
```
<!--directive: hello--> //注意：冒号后面有一个空格
```
#####定义一个指令
```
var app=angular.module("appModule",[]);
app.directive("girl",function(){
     return [
        contoller:function(){
        this;
        }
     ]
})
app.directive("hello",function(){//hello是指令名字和上面格式一样
      return {
          replace:true,
          restrict:"EACM",
          template:`<div>
                   <div></div>
                   <div></div>
                   </div>`，
          template：function(){return '<div></div>'}
          templateUrl:""，
          require:"girl",
          controller:function ($scope){
          
          },
          link：function(scope,element,attrs,gCtrl){
          
          
          },
          scope:true,//或者{}
          transclude:true
      }


})
```
######.directive("hello",function(){})
- 1、hello：是指令名字，和上面的格式中EACM一样
- 2、function：是返回指令对象的函数。返回一个对象
######return {}
- replace:布尔值，将原来指令标签替换掉，要求模板只能有一个根节点，这个属性用来规定生成的HTML内容是否会替换掉定义此指令的HTML元素。
-  restrict：字符串， 限制使用格式范围，默认E和A必须大写
- template：字符串或函数，模板的根节点只能有一个，如果需要可以在外面套一个标签，当该属性的值为function的时候，那么该方法返回的就是代表模板的字符串，同时也可以在里面使用{{}}这个表达式。
- require：字符串，指令的名字，作用是找到这个指令，"?girl",如果没有依赖到,使用问号，得到值是null，否则会报错，"?"可有可无;"^?girl","^"是指先在自身找，如果找不到会向父元素上找对应的指令，找到后link的第四个参数是指依赖的指令的conroller函数的一个实例。上面的girl指令中controller函数中的this值gCtrl。如果被依赖的指令上没有controller会报错。
- controller:函数，参数$scope是指当前指令所在作用域，不会产生新的作用域，和link中的scope是一样的
- link:函数，它包括三个参数（固定的）：scope、element、attrs。这个link函数主要是 用来添加对DOM元素的事件监听、监视模型属性变化、以及更新DOM的。
   - scope:代表当前指令所在的作用域
   - element:代表当前指令所在的标签，是一个JQ对象,angular.element相当于$
   - attrs:代表当前指令上所有属性的集合
   - gCtrl:代表依赖的指令中的controller实例
- scope:布尔或者对象，给当前指令产生呢过一个作用域，
  另一种方式：{} 默认值false，scope:{} 大括号的区别，大括号不会继承父作用域的属性，相当于开辟了一个和rootScope平级的作用域，每一个标签有独立的作用域。
  
-  transclude:布尔，会产生一个作用域，会将指令中夹着的部分，插入放到带有ng-transclude的标签中

######@
######=
######& 


####$watch
脏值检测：对比两次的变化触发对应的回调函数，将所有数据放在一个数组中，有一个变化所有$watchers执行一遍
######$watch方法监测Model的变化
```
app.controller("myCtrl",function($scope){
   $scope.$watch("name",function,true)
})
```
- 第一个参数：监听的对象，可以是一个angular表达式"name",也可以是一个函数function(){return $scope.name}
- 第二个参数：是一个函数，function(newVal,oldVal,scope){}
      - newVal:新值
      - oldVal:旧值
      - scope:作用域的引用
- 第三个参数：是否深度监听，如果是true告诉angular监测监听对象的每一个属性的变化，如果监听的是一个数组或者对象应该使用它。
####$apply
- Scope提供的方法，它是传播Model的变化
- $apply的使用情景：angular外部的控制器（DOM事件，外部回调函数（jQuery）等）调用了angular函数之后必须调用$apply(),需要命令angular刷新自己的视图
- 注意：如果可以把要执行的代码或函数传递给apply，而不要自己执行完再调用$apply。
```
<div ng-controller="myCtrl">{{name}}{{age}}</div>
app.controller("myCtrl",["$scope","$timeout",function($scope,$timeout){
     $scope.name:"teddy";
     $scope.age:20;
     setTimeout(function(){
       $scope.name:"hai";
       $scope.age:21;
     },1000)
}])
```
> 一秒后页面没有变化，原因是无法传播model变化后的值
```
<div ng-controller="myCtrl">{{name}}{{age}}</div>
app.controller("myCtrl",["$scope","$timeout",function($scope,$timeout){
     $scope.name:"teddy";
     $scope.age:20;
     setTimeout(function(){
        $scope.$apply(function(){
                      $scope.name:"hai";
                      $scope.age:21;  
                      })
               },1000)
}])
```
> 一秒后页面会刷新，name和age的值变了。如果用$timeout就不用$apply也能实现刷新。因为$timeout是angular提供的服务。
> $interval ---angular的定时器  $interval.cancel(timer) ---取消定时器
> $timeout  ---angular的定时器  $timeout.cancel(timer) ---取消定时器

####$http
#####链式调用
```
$http({
   url:"data.json",
   method:"get"
 }).success(function(data,status,config,headers){
      //响应成功
 }).error(function(data,status,config,headers){
      //处理响应失败
 })
```
#####返回一个promise对象，可以用promise对象的then方法
```
$http({
   url:"data.json",
   method:"get"
}).then(function(resp){
         //resp是一个响应对象
      },function(resp){
         //带有错误信息的resp
      })
```
> $http.jsonp() 这是一个jsonp的请求方式，用法同上
```
$http.jsonp($sce.trustAsResourceUrl("https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=" + $scope.query),
         {jsonpCallbackParam: 'cb'})
         .then(function (res) {
                $scope.arr=res.data.s
            }, function () {
            })
```
> $sce.trustAsResourceUrl作为一个可信任的路径
> window.open('https://www.baidu.com/s?wd='+$scope.query); //新页打开
> window.location.href='https://www.baidu.com/s?wd='+$scope.query; //当前页打开

####angular提供了五种服务
1、服务大单例的方法都是共用的
2、实现复用代码
- provider：可以配置
- factory
- service
- constant
- value
#####provider
> 执行顺序
> 1、provider默认实例化
> 2、config
> 3、$get
> 4、Calc.sum()
```
app.config(function(CalcProvider){
        //在要配置的服务后面加Provider后缀
       //CalcProvider是provider的实例
})
app.provider("Calc",function(){
     this.$get=function(){
        this;//this指向谁看谁调用的$get,也就是provider第二个参数函数的实例
        return {
         sum:function(){//这个函数中的this是Calc对象}
         }
     }
})
app.controller("myCtrl",function($scope,$http,Calc){
    Calc.sum();//Calc是一个对象
})
```
###### app.config(function(CalcProvider){})
- 配置服务，参数是一个函数，函数中的参数是要配置的服务后面加Provider后缀，CalcProvider是provider的一个实例
######app.provider("Calc",function(){this.$get=function})
- provider默认会被实例化
- 当我们把这个服务放到控制器中，会自动调用$get方法
- $get方法返回一个对象
######app.controller("myCtrl",function($scope,$http,Calc){Calc.sum();})
- Calc参数是一个对象
- Calc.sum中的this就是Calc对象
#####factory
```
app.factory("Calc",function)
```
- factory是基于provider的，不能进行配置,第二个参数就相当于provider中的$get
####事件
#####$emit：向上级传播
```
$scope.$emit("事件名"，data)
```
- "事件名"，和$on中的一样
- data：要传递的数据
#####$broadcast：向下级传播
#####$on
```
$scope.$on("事件名",function(e,data){})
```
- e:代表的事件源，自带的
- data：接受到传过来的数据