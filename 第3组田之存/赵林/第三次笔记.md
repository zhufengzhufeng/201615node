###node
####global
- 自执行函数中的this是global
- 用var声明的不会挂载在global属性上
- 挂载在global对象上的属性 可以在任何模块中使用
- 1.Buffer是global上的属性
- Buffer 形参(exports require module __dirname __filename)
- 1.二进制 逢二进一 16进制 逢16进1  Buffer展现给我们的是16进制
- 2.utf8一个汉字 代表3个字节
- 3.一个字节由八个位组成Bit
- 创建buffer 三种方式(固定大小) 非常像数组 会将buffer转换成字符串
	+ 1） 长度创建 字符串创建 数组创建
	+ buffer像数组
	+ buffer相当于数组里存的都是内存地址
	+ string,往里面写的字符串 offset,偏移量 length,写入的长度 encoding 默认是utf8
	+ 拷贝方法 将小buffer拷贝到大buffer上
	+ targetBuffer,目标buffer targetStart,目标的开始 sourceStart,源的开始 sourceEnd源的结束
	+ concat方法
	+ 1.myConcat list totalLength
	+ 2.判断长度是否传递，如果给了长度就构建一个buffer,将小buffer依次拷贝到大buffer上，过长则将多余的部分 截取掉slice()截取有效长
	+ 3.手动维护长度 在构建buffer，将小buffer依次拷贝到大buffer上 copy
- setTimeout改变this指向使用bind方法
- 进制转换
- parseInt  将任意进制 转换成10进制
- toString  将任意进制 转化为任意进制
- base64 不是一个加密算法， 加密 md5 sha1 sha256
- 将汉字转换成base64 '珠' => 54+g  3*8 = 6*4
- 2进制装换成10进制不得大于64,得到的结果在可见编码中取值
- 将汉字转换成2进制
```
var buffer = new Buffer('珠');
console.log(buffer); //0xe7 0x8f 0xa0
console.log((0xe7).toString(2)); //11100111
console.log((0x8f).toString(2)); //10001111
console.log((0xa0).toString(2)); //10100000
```
- 将2进制转换成10进制
```
console.log(parseInt('00111001',2)); //57
console.log(parseInt('00111000',2)); //56
console.log(parseInt('00111110',2)); //62
console.log(parseInt('00100000',2)); //32
var str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
str+= 'abcdefghijklmnopqrstuvwxyz';
str+='0123456789';
str+='+/';
console.log(str[57]+str[56]+str[62]+str[32]);
```
###fs
核心模块 file system
const fs = require('fs'); //既有同步 又有异步
//能用异步 绝不用同步

//1.读取文件没有会报错
//2.读取默认格式是buffer类型  encoding:null
arrow_fn  templateString class export 解构
### write
- const fs = require('fs');
1.如果写的文件不存在会创建文件
2.默认写入格式是utf8格式
3.文件有内容，清空文件内容
fs.writeFileSync('./a.txt',new Buffer('珠峰'));
如果放入的是buffer格式 会默认toString('utf8');
fs.writeFile('./a.txt',new Buffer('珠峰培训'),function (err) {
    console.log(err);
});
拷贝的方法  同步 readFileSync+writeFileSync
异步 readFile + writeFile
###copy
const fs = require('fs');
//readFile，会淹没可用内存，不能读取比内存大的文件
var path  = require('path'); //核心模块 resolve  join
console.log(path.resolve('1.js'));//以当前路径解析出一个相对路径
console.log(path.join(__dirname,'1.js'));//相当于resolve
function copy(source,target) {//异步
    //先读在写
    fs.readFile(source,function (err,data) {
        if(err)console.log(err);
        //appendFile可以进行累加，不清空内容写入
        fs.writeFile(target,data,{encoding:'utf8',flag:'a'},function (err) {
            if(err)console.log(err);
            console.log('拷贝成功');
        });
    });
};
copy('./name.txt','./name1.txt');

function copySync(source,target) { //同步
    var result = fs.readFileSync(source);
    fs.writeFileSync(target,result);
}
// copySync('./name.txt','./name1.txt');
// readFileSync readFile
// writeFile  writeFileSync
// appendFile appendFileSync
// path.resolve() path.join() 给一个相对路径 解析一个绝对路径
// mkdirSync mkdir 创建目录
// rmdirSync rmdir 删除目录
// unlinkSync unlink 删除文件
// readdirSync readdir 读取目录
// existsSync exists 是否存在
// statSync  stat 判断文件状态
####readStream
const fs = require('fs');
//1.读取保证文件必须存在
//2.默认返回的是可读流对象
//3.highWaterMark: 65536, 64k 一次读多少
//4.encoding 是null 默认读出的内容是buffer
var rs = fs.createReadStream('./1.txt',{highWaterMark:1});
//默认的时候 非流动模式，监听了data 叫流动模式
var arr = [];
rs.on('data',function (data) { //如果你监听了data事件，会不停的触发rs.emit("data",data)
    rs.pause();
    console.log('停一会');
    arr.push(data);
    setTimeout(function () {
        rs.resume(); //重新出发data事件
    },1000);
});
rs.on('end',function () { //结束的事件  rs.emit('end');如果没读完 不会触发
    console.log(Buffer.concat(arr).toString());
});
rs.on('error',function (err) { //监听错误信息的
    console.log(err);
});
// on('data') on('end') on('error') pause() resume()
####writeStream
const fs = require('fs');
//1.写的默认编码 utf8
//2.文件不存在会创建文件，会清空原有内容
//3.ws代表的是可写流
//4.highWaterMark  16384 16*1024
var ws = fs.createWriteStream('./2.txt',{highWaterMark:4});
//写入 write() 写完 end()
var flag = ws.write('abcd1',function () { //buffer or string
    console.log('成功');
});
//flag表示是否可以继续写入
ws.end('在吃一口');// 表示合上嘴，强制将没有写完的内容写完，在关闭
//end可以传递参数，表示在合上嘴之前 在写点东西
console.log(flag);
####pipe
//1.10G 先读一次 64k ，开始写入 16k，如果写不进去了,暂停读取，等待写完后在读取，读取成功后，关闭写入
var fs = require('fs');
function pipe(source,target) {
    var rs = fs.createReadStream(source);
    var ws = fs.createWriteStream(target);
    rs.pipe(ws);//想看到文件中的内容，pipe的好处 异步，不会淹没可用内存
    //on('data') on('end') on('error') pause() resume() on('drain') write() end()
    //1.先监听读取事件rs.on('data');
    rs.on('data',function (data) {
        //2.先写入ws.write，如果返回值为false，rs.pause();
        var flag = ws.write(data);
        if(!flag){
            rs.pause();
        }
    });
    //3.ws.on('drain')可写流干了,在进行读取rs.resume();
    ws.on('drain',function () {
       rs.resume();
    });
    //4.rs.on('end') 读完了 ws.end()关闭写的文件
    rs.on('end',function () {
        ws.end();
    });
}
pipe('1.txt','3.txt');

序列化表单 将表单的内容 序列化成想要的内容
1.页面刷新 要先获取数据  /getUser
 2.删除功能 /deleteUser
```
process
 *   Buffer
 *   global
 *   clearImmediate: [Function],
     clearInterval: [Function],
     clearTimeout: [Function],
     setImmediate: [Function],
     setInterval: [Function],
     setTimeout: [Function],
     console: [Getter]
```
(exports,require,module,__dirname,__filename)这五个参数是形参，可以在任何文件中使用，我们也叫他全局变量
```
console.log(__dirname); //路径是不可变的
console.log(__filename);//当前文件所在文件夹的绝对路径
```
process.pid 当前的进程id
process.kill()杀死某个进程
process.exit()退出自己
process.cwd() current working directory 可以更改
process.chdir() 改变目录
console.log(process.cwd());
console.log(__dirname); //当前绝对路径
## 单线程和多线程
- node主线程是单线程的，进程中包含线程，正常java 一个进程中包含多个线程，node中一个进程只能包含一个线程，允许开子进程。

## 同步和异步
- 代码从上到下执行，先走同步在走异步，异步不会阻塞主线程
- 五个人一起吃饭

## 阻塞和非阻塞
- 针对内核来说的，非阻塞是异步的前置条件

## 回调（回头再调）
- 用回调来解决异步编程问题

## 事件环

## 异步的文件读写，callback,定时器，能用异步 不用同步

## node全局对象
- 在任意地点可以直接访问的
- 在global上挂载的都是全局对象

1.文件模块 自己写的模块 引用文件模块要使用相对路径
2.核心模块、内置模块 node自带的本来就有的天生的
3.第三方模块，需要安装下载
1）使用某个模块中的变量，可以挂载在全局下，让所有模块来使用
## js中模块 
- (seajs cmd,requirejs amd,node commonjs)
- cmd 就近依赖,amd 依赖前置
- 单例(不能保证完全解决冲突,调用时调用名字过程)
- 闭包，node中实现模块化 采用的是读写

## commonjs(提高了可维护性，有利于分工协作，高内聚低耦合)
- 如何定义模块    
创建一个js文件，每个文件就是一个模块，多个模块可以组成一个包
- 如何导出一个模块  
exports/module.exports  
- 如何使用一个模块  
require
