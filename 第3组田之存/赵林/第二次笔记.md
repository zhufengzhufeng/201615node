###第二次笔记
## 1.git
安装brew在mac上
mac http://brew.sh
```
brew install git 
```
### 1.1 告诉git你是谁
```
git config --global user.name xxxxx
git config --global user.email xxxxx
git config --list
```
### 1.2 初始化git
```
git init
```

### 创建并进入目录 
```
mkdir gitTest && cd gitTest
```

### ls显示所有文件
```
ls -al 显示隐藏的
```

### 创建文件
```
touch index.txt
cat index.txt 查看内容
```

### 查看git状态
```
git status 
```

### 添加到暂存区
```
git add .
```

### 提交到历史库
```
git commit -m 'write hello world'
```

### 对比代码
工作区和暂存区
```
git diff
```
暂存区和历史区 
```
git diff --cached
```
工作区和历史区 
```
git diff master(分支名)
```

## 查看日志
```
git log 过多可以使用上下键查看，不想看可以q退出
```

## 查看所有日志
```
git reflog
```
## 回滚
```
git reset --hard 版本号
```
## vi编辑
```
vi index.txt
i 编辑模式
esc + :wq 保存并退出  强制退出q!
```


## 分支管理
- 查看分支
```
git branch 
```
- 创建分支
```
git branch <branchName>
```
- 切换分支
```
git checkout <branchName>
```
- 删除分支（不能自己删除自己）
```

git branch -D <branchName>
```
- 创建并切换(相当于将当前内容克隆一份)
```
git checkout -b <branchName>
```
- 在master上合并dev分支
```
git merge dev
```
- 产生冲突(手动解决提交新的版本)

## 创建仓库
- 创建空仓库，写一个仓库名
```
new repository
```

- 本地要建一个README.md .gitignore
```
echo '.idea' >> .gitignore
echo 'welcome' >> README.md
```

- 提交并关联仓库
```
git add .
git commit -m ''
git remote add origin 地址
git remote -v 查看所有关联
git remote rm origin 删除
```
- 推送到远程仓库上
```
git push origin master(可以推送其他分支) -u(upstream 下次提交不必再输入origin master)
```

## 发布静态页
- 发布的静态页必须在gh-pages分支
```
git checkout -b gh-pages
git add .
git commit -m 
git push origin gh-pages
```

## 讲师有一个仓库 
- 组长fork我的仓库
- 将信息 放到自己的文件夹下提交代码
- 推送到github上
- 发送pull request请求合并

## 组长给组员开通权限
- 组员clone最新代码
- 放入自己的文件提交
- 拉取组长的仓库的最新代码
```
git pull 
```
- 再次推送

## 组长推送给老师
- 先拉取自己组的最新代码
```
git pull 
```
- 拉取老师的最新代码
```
git remote add teacher https://github.com/zhufengzhufeng/201615node.git
```
- 推送到自己的仓库上
```
git push origin master
```
- pull request

###global
> 自执行函数中的this = global
> 用var声明的不会挂载在global属性上
> 挂载在global对象上的属性 可以在任何模块中使用
```
process
Buffer
global
clearImmediate: [Function],
clearInterval: [Function],
clearTimeout: [Function],
setImmediate: [Function],
setInterval: [Function],
setTimeout: [Function],
console: [Getter]
```
###setImmediate
默认nextTick>setImmediate>= setTimeout

###_dirname
```
这五个参数是形参，可以在任何文件中使用，我们也叫他全局变量
(function(exports,require,module,__dirname,__filename){
5.__dirname
})()
C:\Users\10354_000\Desktop\201615node\node\2.node  绝对路径
console.log(__dirname);路径是不可变的
console.log(__filename);当前文件所在文件夹的绝对路径
```
###process
```
process.pid 当前的进程id
process.kill()杀死某个进程
process.exit()退出自己
process.cwd() current working directory 可以更改
process.chdir() 改变目录
```

## 单线程和多线程
- node主线程是单线程的，进程中包含线程，正常java 一个进程中包含多个线程，node中一个进程只能包含一个线程，允许开子进程。

## 同步和异步
- 代码从上到下执行，先走同步在走异步，异步不会阻塞主线程
- 五个人一起吃饭

## 阻塞和非阻塞
- 针对内核来说的，非阻塞是异步的前置条件

## 回调（回头再调）
- 用回调来解决异步编程问题

## 事件环

## 异步的文件读写，callback,定时器，能用异步 不用同步

## node全局对象
- 在任意地点可以直接访问的
- 在global上挂载的都是全局对象

## js中模块 
- (seajs cmd,requirejs amd,node commonjs)
- cmd 就近依赖,amd 依赖前置
- 单例(不能保证完全解决冲突,调用时调用名字过程)
- 闭包，node中实现模块化 采用的是读写

## commonjs(提高了可维护性，有利于分工协作，高内聚低耦合)
- 如何定义模块    
创建一个js文件，每个文件就是一个模块，多个模块可以组成一个包
- 如何导出一个模块  
exports/module.exports  
- 如何使用一个模块  
require

###directive
```
<!--指令分为四种格式-->
<!--Element E-->
<my-drag></my-drag>
<!--Attributes A-->
<div my-drag></div>
<!--Class C-->
<div class="my-drag"></div>
<!--Comment M 前后必须用空格，不建议使用-->
<!-- directive:myDrag -->


<!--指令分为两类 自带指令  自定义指令-->
<!--自定义指令
    装饰型指令 赋予标签一些功能  link函数
    组件式 把标签 替换成一个组件 template
<script>
var app = angular.module('appModule',[]);
    //param1 指令的名字
    app.directive('myDrag',function () {
        return {
            replace:true, //将原指令标签替换掉，要求模板只能有一个根节点
            restrict:'EA', //限制使用范围 默认范围是EA,范围的标识必须大写
            template:`<div>
                        <div>Hello</div>
                        <div>zfpx</div>
                      </div>` //模板的根节点只能有一个
        }
    });
    </script>
```
## yarn
下载yarn
```
npm install yarn -g
```

## 初始化一个package.json
```
yarn init
```

## 安装包
```
yarn add angular
yarn add gulp --dev
yarn remvoe gulp --dev
```
ng-show/ng-hide ng-if
    频繁切换用show/hide  操作的是样式
    一次就确定下来的内容 如果值为false内部代码不执行 操作的dom, repeat经常和if连用  if会产生一个作用域
    脏值检测 对比两次的变化，触发对应的回调函数,将所有数据放在一个数组中，有一个变化 所有$watchers执行一遍
    ###services
```
<script>
    //1.服务是单例的 ，方法都是公用的
    var app = angular.module('appModule',[]);
    //2.实现复用代码 $rootScope, localStorage
    //3.angular提供了五种服务  "provider factory" service constant value
    //4.provider是最大的服务，可以进行配置,其他4中不能配置
    app.config(function (CalcProvider) { //在要配置的服务后面 增加Provider后缀
        //console.log(CalcProvider); //是provider的一个实例
        CalcProvider.currency = '£'
    });
    //运行顺序 new Provider > config > $get
    app.provider('Calc',function () { //当我们将Storage放到控制器中，会自动调用$get方法
        this.currency = '$'; //在实例上增加了属性
        this.$get = function () {
            //var that = this; //谁调用的$get(实例)
            return {
                sum: (a,b) => this.currency +(a+b)
            }
        };
    });//provider默认就会被实例化
    app.controller('oneCtrl',function ($scope,$http,Calc) {  //sum()
        console.log(Calc.sum(1,2));
    });
    app.controller('twoCtrl',function ($scope,$http) {
    });
    //$http $sce
</script>
```
###factory
- factory 不具有配置能力，因为$get方法在我们的config方法后执行 配置后会被覆盖掉
- factory是基于provider的 后面的函数就是provider的$get
- 最大的是provider factory是基于provider的  service 是基于factory的  value是基于 factory的
- 控制器间的交互 1.$rootScope, 服务， 事件(观察者模式) $on  $emit  $broadcast