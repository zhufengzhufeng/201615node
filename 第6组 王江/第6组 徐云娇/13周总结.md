### react 13周1天

## 安装 babel
从6.0开始，分成了二个模块
- babel-cli 提供命令行工具，可以在CMD里执行此命令
- babel-core 本地的核心模块 会安装在当前项目的node_modules里去

-g --global 全局

```sh
npm install babel-cli -g
```
1. 从安装角度来讲
全局安装其实是装到了以下目录，不管在哪里，都会装到此目录下
```
C:\Users\Administrator\AppData\Roaming\npm
```
2.在命令行里输入babel的时候，windows会在环境变量path中寻找配置的目录，
会在这些目录下面依次寻找此命令，如果找到了，则执行它。

## 本地安装babel
在本地安装之前先去初始化一下项目
```sh
npm init -y
```
执行此命令是为了在项目下面生成package.json文件
因为在执行 `npm install babel-cli -S`,会在当前目录下面找package.json文件，如果找到了，则会装前当前文件夹下的node_modules里，如果没找到，会向上层找package.json文件


## npm script
npm脚本是一个对象，有属性和值组成
属性是一个字符串，名称自己任意起
值是一个可以在命令行中执行的命令
执行 `npm run 脚本名` 就可以执行此命令





```
* 左边永远是对象的属性名
 * 右边永远是变量名
 * 定义对象的时候是把变量的值赋给对象的属性
 * 解构赋值的时候是把对象的属性赋给变量
 */
var name1 ='1';
var age1 = 9;
var obj = {name:name1,age:age1};
obj = {name:'2',age:10};
// key代表对象的属性 代表当前作域内的变量
var {age:age1,name:name1} = obj;
console.log(name1,age1);
```
###reduce 
```

let ary = [1, 2, 3, 5, 9, 4];
// reduce 收敛 处理
//1参数是处理函数 2参数是初始值
/let result = ary.reduce(function(curVal,item){
 return curVal+item;
 },0);
 console.log(result);*!/
//返回一个数组中的最大值
let result = ary.reduce(function (curVal, item) {
    console.log(curVal, item);
});

```


```
class Point{
    //构造函数用来初始化私有属性 当实例化一个类的时候会立刻调用的
    constructor(x,y){
        this.x = x;
        this.y = y;
    }//私有
    static getColor(){
        console.log('red');
    }//自己的一个属性
    toString(){
        return `(${this.x},${this.y})`;// (x,y)
    }//公有
}


```



```
// 子类继承了父类
class ColorPoint extends Point{
  //当子类继承父类的时候，必须先调用父类的构造函数
  constructor(x,y,color){
      super(x,y);//super代表父类的构造函数
      this.color = color;
  }
  getColor(){
      console.log(this.color);
  }
  /*//在原型上的方法里super表示父类
  toString(){
      //console.log(`${this.color}(${this.x},${this.y})`);
      return `${this.color}${super.toString()}`
  }*/
}
let colorPoint = new ColorPoint(100,100,'red');
console.log(colorPoint.toString());



function ColorPoint(x,y,color){
    Point.call(this,x,y);
    this.color = color;
}

ColorPoint.prototype = Object.create(Point.prototype);
ColorPoint.prototype.getColor = function(){

}



```


##react 13周 2天
####1 react
```
//render：渲染
//tag：标签
 //props:{width:'400px'}：属性
//children：孩子们
//createClass：创建一个类
 // getDefaultProps(){//获得默认属性对象
      return {name:'无名'};
  },
   //获得初始的状态对象
  getInitialState(){
    return {number: 0,name:'zfpx'};
  },

// handleClick(offset){//处理点击事件
    //当修改完状态之后会自动触发重新render
    //setState用来修改状态的，

//propTypes:{ //规定了外界使用此组件的时候必须入的属性名称和类型
    //name:React.PropTypes.string.isRequired,
    age:React.PropTypes.object.isRequired,
    mobile:


 // React.Children.map是一个工具方法，可以帮我们自动处理单个对象和多个对象的情况

//babel转译JS代码
//* react.js React
// * react-dom.js ReactDOM

render 是渲染页面的

//this.props.children啥意思

//{...attrs}//展开

 //返回一个状态对象，有一个属性叫text,值是一个空的字符串
  getInitialState(){
    return {text:''};
  },
  //onChange处理值改变事件；
// 可以给每个虚拟DOM配置一个 ref属性，值就是此真实DOM的引用名了
// refs是固定的是它是一个对象，属性名就是引用名，值是真实DOM元素

this.refs.myTxt.focus();啥意思？

setState 设置状态
totalPages={4} 一共几页
pageNumber={3}当前第几页
// let index = event.target.dataset.index;
    this.setState({index});
```
///////////////////////////////////////
就是把html标签添加到页面容器中

1参数   是要添加到页面的标签
2参数    是添加到哪里去 ,是容器

jsx  jsvascript+（xml+html）混合写法

1.虚拟DOM元素  dom里的p  标签是不一样的
在html代码中如果遇到{开头的标识是js表达式}
 2 <号是html

/*let style = {color:'red'};
ReactDOM.render(
  <p style={style}>hello</p>,document.querySelector('#app')
);*/


```
//Message是一个类，
let Message=React.createClass({
   render(){
       return <div>hello</div>
   } //相当于类的原型，
});
ReactDOM.render(<Message/>,docment.querySelector('#app'))
//实例调用，render方法，

//大写的Message就是一个组件，
//如果小写就是dom虚拟标签，
```

###1.1react-1

###2jsc.js

### 3  

/**
 * 定义组件
 * 组件是一个类，需要实现一个render方法，render方法需要返回一个React虚拟DOM元素
 * 1.组件首字母要大写
 * 2.render方法要返回并且只能返回一个顶级虚拟DOM元素,也就是说只能有一个根节点
 *
 * 当react-dom渲染的时候，先得到标签，判断它是大写开头还是小写开头
 * 1. 如果是大写开头的话，那就是一个组件。先找到组件类的定义，然后实例化这个类，然后调用此实例的render方法得到一个虚拟DOM元素。然后把此虚拟DOM元素插入到容器内部
 * 2.如果是小写字母开头，那就是一个虚拟DOM元素，然后把此虚拟DOM元素插入到容器内部
 */


4
//规定了外界使用此组件的时候必须入的属性名称和类型
  propTypes:{
    name:React.PropTypes.string.isRequired,
    age:React.PropTypes.object.isRequired,
    mobile: function(props, propName, componentName) {
      if (!/1[359]\d{9}/.test(props[propName])) {
        return new Error('手机号不合法!');
      }


###13周 3天和4天笔记   珠峰博客
multer
resolve
session
dest 设置目的地
skip  跳过
 limit  限制
exports 出口
 res.redirect('back');//滚回原来页面
findOne 查询一次
find 查询所有
connect连接
flash ：闪关灯
navbar-right 向右对齐
avatar头像
(
enctype 上传文件 （多块的意思）
用multer解析
)

res.render('index',{title:'首页',articles})把数据渲染到首页
avatar：string 没他保存不进去
mongoose.Schema 类型
populate（填充的意思） 字符串转对象


include模板文件夹
<%- include ../include/header.html%>头模板
<%- include ../include/footer.html%>尾模板


app.use(session({
    resave:true,//每次保存session
    saveUninitialized:true,//保存未初始化session
    cookie:{maxAge:1000*3600},
    secret:'zfpx',//加密cookie秘钥
    store:new MongoStore({url})   //指定session数据的存储位置
}));

use 201615blog 找到数据库  cmd操作
db.articles .drop()从当前集合删除这个集合cmd操作
/////////////////////////////////////////////////////////////
1 let article = req.body;//得到客户端提交的文章对象

2//从当前会话中得到用户的ID，然后赋给文章的user属性
  article.user = req.session.user._id;
3 res.redirect('back');//滚回原来页面
4  exports 出口

5//真正渲染模板是 res.locals.success='hello'，渲染之前会把第二个参数对象属性赋给res.locals
  //需要把user属性从字符串转成对象 populate
  //要查询标题中包含关键字

6 skip  跳过
    limit  限制

7   
```Article.find(query).skip((pageNum-1)*pageSize).limit(pageSize).populate('user').exec(function(err,articles){
      res.render('index',{
        title:'首页',//标题
        articles,//当前页的文章列表
        keyword:req.query.keyword,//关键字
        pageNum,//当前页码
        pageSize,//每页的条数
        totalPages:Math.ceil(count/pageSize)//总页数
      });

```

8
```
//因为系统是在server.js上启动的，所有路径的当前目录
//就是项目根目录
let upload = multer({dest:'./public/uploads'});
//运行Router方法之后会返回一个路由中间件的实例
//路由中间件本质上是一个中间件
let router = express.Router();
//这里的路径是子路径
router.get('/signup',checkNotLogin,function(req,res){
    res.render('user/signup',{title:'用户注册'});
});
//1.得到请求体 2.定义model 3.调用model.create方法把此用户保存到数据库中
router.post('/signup',checkNotLogin,upload.single('avatar'),function (req,res) {
    let user = req.body;
    //给头像图片的路径赋值
    user.avatar = `/uploads/${req.file.filename}`;

```

9
```
if(doc){
               //在session写入了成功类型的消息
                req.flash('success','恭喜你登录成功!');
                req.session.user = doc;
                res.redirect('/');
            }else{
              req.flash('error','很遗憾你登录失败,请重新登录!');
              res.redirect('back');
```


10
```
/**
 * req.body= { username: '12', password: '2', email: '2@2.com' }
 * 浏览器把填写的表中的文本类型的字段转成的对象
 *
 * req.file
 * {
 * fieldname: 'avatar',  字段名 input框的 name属性
  originalname: 'head.png', 在本地上传前的原始文件名
  mimetype: 'image/png', 内容类型 大类型/小类型
  destination: './public/uploads',上传到服务器后保存的路径
  filename: 'db549107acd9596d7c2a723431002365', 保存的文件名
  path: 'public\\uploads\\db549107acd9596d7c2a723431002365',
  size: 14245 }
 **/
```

11
```
//连接数据库
let url = require('./config').url;
mongoose.connect(url);

```
12
```
//定义模型骨架
//如何手工强行指定集合的名称
let UserSchema = new mongoose.Schema({
    username:String,
    password:String,
    email:String,
    avatar:String
},{collection:'user'});
```

13
```
let ArticleSchema = new mongoose.Schema({
  title:String,
  content:String,
  createAt:{type:Date,default:Date.now},
  user:{type:ObjectId,ref:'User'}//ref 引用，表示自己是一个外键，引用的是User集合的主键
})

主键一般指：唯一的ID 
外键：指调用了主键（如：调用了主键id，想拿到主键里的其他值）
外键值和主键值一样
```

14
let session = require('express-session');
let MongoStore = require('connect-mongo')(session);
//这是一个把信息写在session中的中间件


15
let flash = require('connect-flash');
导入flash

16
//指定public目录为静态文件根目录
app.use(express.static(path.resolve('public')));


17
//此中间件会判断请求体的类型，如果是json,自己就处理，如果不是json,会走next,是通过请求头中的 Content-Type:application/x-www-form-urlencoded来判断的
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({extended:true}));

18
// req.session
let url = require('./config').url;
app.use(session({
    resave:true,//每次保存session
    saveUninitialized:true,//保存未初始化session
    cookie:{maxAge:1000*3600},
    secret:'zfpx',//加密cookie秘钥
    store:new MongoStore({url})   //指定session数据的存储位置
}));
19
//此中间件会向req.flash。可以读写消息
// req.flash(type,msg) req.flash(type)
app.use(flash());

flash ：闪关灯
只能读取一次
一个参数是取值
两个参数是赋值

20
//目标是把success error从req.flash取出来赋给
// res.locals 是真正渲染模板的对象
app.use(function(req,res,next){
 res.locals.success = req.flash('success').toString();
 res.locals.error = req.flash('error').toString();
 res.locals.user = req.session.user;
 res.locals.keyword = '';
 next();
});

21
//引入模板
app.set('view engine','html');
//指定模板的存放根目录为当前文件夹下面的views目录
app.set('views',path.resolve(__dirname,'views'));
//指定用__express方法来渲染.html模板
app.engine('html',require('ejs').__express);
app.use('/',index);
app.use('/user',user);
app.use('/article',article);
//监听8080端口并启动一个服务器
app.listen(8080);




# 珠峰博客
## 1. 在github上创建项目并下载到本地
```sh
git clone https://github.com/zhufengnodejs/201615blog.git
```
> 因为webstorm的配置文件不需要提交github,所以会把`.idea`文件夹添加到`.gitignore`里

## 2. 初始化项目配置文件
```sh
npm init -y
```

## 3. 安装依赖的模块
```sh
npm install express mongoose ejs debug body-parser cookie-parser connect-flash connect-mongo multer --save
```

## 4. 跑通路由
###功能
1. 用户注册、登录、退出登录
2. 发表文章、查看文章列表

1. /user/signup /user/signin /user/signout
2. /article/add /article/list


## 5. 用户注册
1. 当客户端通过 `/user/signup` 访问服务器的时候，服务器会返回一个空白注册表单。
2. 当用户填写完表单表，会点击提交按钮，这时浏览器会把表单的数据进行序列化转成化查询字符串的格式，并放在请求体里提交给服务器
3. 服务器接收到请求后，会把请求体中的数据通过`body-parser`中间件拿到。转成**JS**对象赋给`req.body`.
4. 把此对象保存数据库里，成功后跳转到登录页。如果失败了会回到注册页。











































































